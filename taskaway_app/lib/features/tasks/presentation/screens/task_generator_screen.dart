import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:taskaway_app/core/services/groq_service.dart';
import 'package:taskaway_app/features/tasks/data/models/task_model.dart';
import 'package:taskaway_app/features/tasks/data/repositories/task_repository_impl.dart';
import 'package:taskaway_app/features/tasks/presentation/providers/task_providers.dart';

final taskGenerationStateProvider = StateProvider<AsyncValue<List<String>>>(
  (ref) => const AsyncValue.data([]),
);

class TaskGeneratorScreen extends ConsumerStatefulWidget {
  const TaskGeneratorScreen({super.key});

  @override
  ConsumerState<TaskGeneratorScreen> createState() => _TaskGeneratorScreenState();
}

class _TaskGeneratorScreenState extends ConsumerState<TaskGeneratorScreen> {
  final TextEditingController _descriptionController = TextEditingController();
  final List<bool> _selectedTasks = [];
  bool _isGenerating = false;

  @override
  void dispose() {
    _descriptionController.dispose();
    // Clear generated tasks when leaving the screen
    ref.read(taskGenerationStateProvider.notifier).state = const AsyncValue.data([]);
    super.dispose();
  }

  Future<void> _generateTasks() async {
    if (_descriptionController.text.trim().isEmpty) {
      return;
    }

    setState(() {
      _isGenerating = true;
    });

    try {
      ref.read(taskGenerationStateProvider.notifier).state = 
          const AsyncValue.loading();
      
      final tasks = await GroqService.generateTasksFromDescription(
        _descriptionController.text,
      );
      
      ref.read(taskGenerationStateProvider.notifier).state = 
          AsyncValue.data(tasks);
      
      setState(() {
        _selectedTasks.clear();
        _selectedTasks.addAll(List.filled(tasks.length, true));
      });
    } catch (e, stackTrace) {
      log('Error generating tasks: $e', stackTrace: stackTrace, name: 'TaskGenerator');
      ref.read(taskGenerationStateProvider.notifier).state = 
          AsyncValue.error(e, stackTrace);
    } finally {
      setState(() {
        _isGenerating = false;
      });
    }
  }

  Future<void> _addSelectedTasks() async {
    final tasks = ref.read(taskGenerationStateProvider).value ?? [];
    if (tasks.isEmpty) return;

    final repository = ref.read(taskRepositoryProvider);
    int added = 0;

    try {
      for (var i = 0; i < tasks.length; i++) {
        if (i < _selectedTasks.length && _selectedTasks[i]) {
          final now = DateTime.now();
          final task = Task(
            id: '',  // Will be generated by Supabase
            title: tasks[i],
            createdAt: now,
            updatedAt: now,
          );
          await repository.addTask(task);
          added++;
        }
      }

      if (added > 0) {
        // Refresh task list
        ref.invalidate(tasksProvider);
        
        // Clear generated tasks after adding them
        ref.read(taskGenerationStateProvider.notifier).state = const AsyncValue.data([]);
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Added $added tasks successfully')),
          );
          Navigator.of(context).pop();  // Return to task list
        }
      }
    } catch (e) {
      log('Error adding generated tasks: $e', name: 'TaskGenerator');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to add tasks: $e')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final generatedTasks = ref.watch(taskGenerationStateProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Smart Task Generator'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () {
            // Clear generated tasks when going back
            ref.read(taskGenerationStateProvider.notifier).state = const AsyncValue.data([]);
            Navigator.of(context).pop();
          },
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'Describe your tasks in natural language:',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: _descriptionController,
              maxLines: 5,
              decoration: const InputDecoration(
                hintText: 'Example: I need to plan a team meeting for next week with 5 colleagues...',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            FilledButton.icon(
              onPressed: _isGenerating ? null : _generateTasks,
              icon: _isGenerating 
                ? const SizedBox(
                    width: 20, 
                    height: 20, 
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: Colors.white,
                    )
                  ) 
                : const Icon(Icons.auto_awesome),
              label: Text(_isGenerating ? 'Generating...' : 'Generate Tasks'),
            ),
            const SizedBox(height: 24),
            const Divider(),
            const SizedBox(height: 8),
            const Text(
              'Generated Tasks:',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Expanded(
              child: _buildTaskList(generatedTasks),
            ),
          ],
        ),
      ),
      bottomNavigationBar: _buildBottomBar(),
    );
  }

  Widget _buildTaskList(AsyncValue<List<String>> tasksState) {
    return tasksState.when(
      data: (tasks) {
        if (tasks.isEmpty) {
          return const Center(
            child: Text(
              'No tasks generated yet.\nDescribe your project or goals above.',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Colors.grey,
                fontSize: 16,
              ),
            ),
          );
        }
        
        return ListView.builder(
          itemCount: tasks.length,
          itemBuilder: (context, index) {
            // Ensure _selectedTasks has enough elements
            if (index >= _selectedTasks.length) {
              _selectedTasks.add(true);
            }
            
            return Card(
              elevation: 1,
              margin: const EdgeInsets.symmetric(vertical: 4),
              child: CheckboxListTile(
                title: Text(
                  tasks[index],
                  style: const TextStyle(fontWeight: FontWeight.w500),
                ),
                value: _selectedTasks[index],
                onChanged: (value) {
                  setState(() {
                    _selectedTasks[index] = value ?? false;
                  });
                },
                secondary: IconButton(
                  icon: const Icon(Icons.edit),
                  onPressed: () => _editTask(index, tasks[index]),
                ),
              ),
            );
          },
        );
      },
      loading: () => const Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('Generating tasks...'),
          ],
        ),
      ),
      error: (error, _) => Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(
              Icons.error_outline,
              color: Colors.red,
              size: 48,
            ),
            const SizedBox(height: 16),
            const Text(
              'Failed to generate tasks',
              style: TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 16,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              error.toString(),
              textAlign: TextAlign.center,
              style: const TextStyle(color: Colors.red),
            ),
            const SizedBox(height: 16),
            FilledButton.icon(
              onPressed: _generateTasks,
              icon: const Icon(Icons.refresh),
              label: const Text('Try Again'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildBottomBar() {
    final tasks = ref.watch(taskGenerationStateProvider).value ?? [];
    final hasSelectedTasks = _selectedTasks.contains(true);
    
    return BottomAppBar(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Row(
            children: [
              _selectAllCheckbox(),
              const SizedBox(width: 8),
              const Text('Select All'),
            ],
          ),
          const Spacer(),
          FilledButton.icon(
            onPressed: (tasks.isNotEmpty && hasSelectedTasks) 
                ? _addSelectedTasks 
                : null,
            icon: const Icon(Icons.add_task),
            label: const Text('Add Selected Tasks'),
          ),
        ],
      ),
    );
  }

  Widget _selectAllCheckbox() {
    final allSelected = _selectedTasks.isNotEmpty && _selectedTasks.every((selected) => selected);
    final tasks = ref.watch(taskGenerationStateProvider).value ?? [];
    
    return Checkbox(
      value: allSelected,
      onChanged: tasks.isEmpty 
          ? null 
          : (value) {
              setState(() {
                for (var i = 0; i < _selectedTasks.length; i++) {
                  _selectedTasks[i] = value ?? false;
                }
              });
            },
    );
  }

  void _editTask(int index, String initialValue) {
    final TextEditingController controller = TextEditingController(text: initialValue);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Task'),
        content: TextField(
          controller: controller,
          autofocus: true,
          decoration: const InputDecoration(
            hintText: 'Task title',
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              final tasks = ref.read(taskGenerationStateProvider).value ?? [];
              if (tasks.isNotEmpty && controller.text.trim().isNotEmpty) {
                final updatedTasks = List<String>.from(tasks);
                updatedTasks[index] = controller.text.trim();
                
                ref.read(taskGenerationStateProvider.notifier).state = 
                    AsyncValue.data(updatedTasks);
              }
              Navigator.pop(context);
            },
            child: const Text('Save'),
          ),
        ],
      ),
    ).then((_) => controller.dispose());
  }
}
